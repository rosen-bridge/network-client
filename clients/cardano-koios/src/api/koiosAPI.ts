/**
 * Generated by orval v6.15.0 🍺
 * Do not edit manually.
 * Koios API
 * Koios is best described as a Decentralized and Elastic RESTful query layer for exploring data on Cardano blockchain to consume within applications/wallets/explorers/etc.

> Note: While we've done sufficient ground work - we're still going through testing/learning/adapting phase based on feedback. Feel free to give it a go, but just remember it is not yet finalized for production consumption and will be refreshed weekly (Saturday 8am UTC).

# Problems solved by Koios
- As the size of blockchain grows rapidly, we're looking at increasingly expensive resources and maintenance costs (financially as well as time-wise)
to maintain a scalable solution that will automatically failover and have health-checks, ensuring most synched versions are returned. With Koios, anyone is
free to either add their backend instance to the cluster, or use the query layer without running a node or cardano-db-sync instance themselves. There will be
health-checks for each endpoint to ensure that connections do not go to a dud backend with stale information.
- Moreover, folks who do put in tremendous amount of efforts to go through discovery phrase - are often ending up with local solutions, that may not be
consistent across the board (e.g. Live Stake queries across existing explorers). Since all the queries used by/for Koios layer is on GitHub, anyone can contribute
or leverage the query knowledge base, and help each other out while doing so. An additional endpoint added will only be load balanced between the servers that
pass the health-check for the endpoint.
- It is almost impossible to fetch some live data (for example, Live Stake against a pool) due to the cost of computation and amount of data on chain. For 
such queries, many folks are already using different cache methods, or capturing ledger information from node. Wouldn't it be nice to have these crunched data that
take quite a few minutes to run be shared and available to be able to pick a relatively recent execution across the nodes? This will be available out of the box as part
of Koios API.
- There is also a worry when going through updates about feasibility/breaking changes/etc. that can become a bottleneck for providers. Since Koios participants
automatically receive failover support, they reduce impact of any subset of clusters going through update process.
- The lightweight query layers currently present are unfortunately closed source, centralised, and create a single point of failure. With Koios, our aim is to
give enough flexibility to all the participants to select their backend, or pick from any of the available ones instead.
- Bad human errors causing an outage? The bandwidth for Koios becomes better with more participation, but just in case there is not enough participation - we will
ensure that at least 4 trusted Koios instances across the globe will be around for the initial year, allowing for enough time for adoption to build up gradually.
- Flexibility to participate at different levels. A consumer of these services can participate with a complete independent instance (optionally extend existing ones), by running only certain parts (e.g. submit-api or PostgREST only), or simply consuming the API without running anything locally.

# Architecture

## How does Koios work?

![High-Level architecture overview](/koios-design.png)

We will go bottom to top (from builder's eyes to run through the above) briefly:

- *Instance(s)* : These are essentially [PostgREST](https://postgrest.org/en/latest/) instances with the REST service attached to Postgres DB populated using [cardano-db-sync](https://cardano-community.github.io/guild-operators/Build/dbsync/). Every consumer who is providing their own instance will be expected to serve at least a PostgREST instance, as this is what allows us to string instances together after health-checks. If using guild-operator setup instructions, these will be provisioned for you by setup scripts.
- *Health-check Services* : These are lightweight [HAProxy](http://www.haproxy.org) instances that will be gatekeepers for individual endpoints, handling health-checks, sample data verification, etc. A builder _may_ opt-in to run this monitoring service, and add their instance to GitHub repository. Again, setting up HAProxy will be part of setup scripts on guild-operator's repo for those interested.
- *DNS Routing* : These will be the entry points from monitoring layer to trusted instances that will route to health-check proxy services. We will be using at least two DNS servers ourselves to not have single point of failure, but that does not limit users to elect any of the other server endpoints instead, since the API works right from the PostgREST layer itself.

# API Usage

The endpoints served by Koios can be browsed from the left side bar of this site. You will find that almost each endpoint has an example that you can `Try` and will help you get an example in shell using cURL. For public queries, you do not need to register yourself - you can simply use them as per the examples provided on individual endpoints. But in addition, the [PostgREST API](https://postgrest.org/en/stable/api.html) used underneath provides a handful of features that can be quite handy for you to improve your queries to directly grab very specific information pertinent to your calls, reducing data you download and process.

## Vertical Filtering

Instead of returning entire row, you can elect which rows you would like to fetch from the endpoint by using the `select` parameter with corresponding columns separated by commas. See example below (first is complete information for tip, while second command gives us 3 columns we are interested in):<br><br>

``` bash
curl "https://api.koios.rest/api/v0/tip"

# [{"hash":"4d44c8a453e677f933c3df42ebcf2fe45987c41268b9cfc9b42ae305e8c3d99a","epoch":317,"abs_slot":51700871,"epoch_slot":120071,"block_height":6806994,"block_time":1643267162}]

curl "https://api.koios.rest/api/v0/blocks?select=epoch,epoch_slot,block_height"

# [{"epoch":317,"epoch_slot":120071,"block_height":6806994}]
```

## Horizontal Filtering

You can filter the returned output based on specific conditions using operators against a column within returned result. Consider an example where you would want to query blocks minted in first 3 minutes of epoch 250 (i.e. epoch_slot was less than 180). To do so your query would look like below:<br><br>
``` bash
curl "https://api.koios.rest/api/v0/blocks?epoch=eq.250&epoch_slot=lt.180"

# [{"hash":"8fad2808ac6b37064a0fa69f6fe065807703d5235a57442647bbcdba1c02faf8","epoch":250,"abs_slot":22636942,"epoch_slot":142,"block_height":5385757,"block_time":1614203233,"tx_count":65,"vrf_key":"vrf_vk14y9pjprzlsjvjt66mv5u7w7292sxp3kn4ewhss45ayjga5vurgaqhqknuu","pool":null,"op_cert_counter":2},
#  {"hash":"9d33b02badaedc0dedd0d59f3e0411e5fb4ac94217fb5ee86719e8463c570e16","epoch":250,"abs_slot":22636800,"epoch_slot":0,"block_height":5385756,"block_time":1614203091,"tx_count":10,"vrf_key":"vrf_vk1dkfsejw3h2k7tnguwrauqfwnxa7wj3nkp3yw2yw3400c4nlkluwqzwvka6","pool":null,"op_cert_counter":2}]
```

Here, we made use of `eq.` operator to denote a filter of "value equal to" against `epoch` column. Similarly, we added a filter using `lt.` operator to denote a filter of "values lower than" against `epoch_slot` column. You can find a complete list of operators supported in PostgREST documentation (commonly used ones extracted below):

|Abbreviation|In PostgreSQL|Meaning                                    |
|------------|-------------|-------------------------------------------|
|eq          |`=`          |equals                                     |
|gt          |`>`          |greater than                               |
|gte         |`>=`         |greater than or equal                      |
|lt          |`<`          |less than                                  |
|lte         |`<=`         |less than or equal                         |
|neq         |`<>` or `!=` |not equal                                  |
|like        |`LIKE`       |LIKE operator (use * in place of %)        |
|in          |`IN`         |one of a list of values, e.g. `?a=in.("hi,there","yes,you")`|
|is          |`IS`         |checking for exact equality (null,true,false,unknown)|
|cs          |`@>`         |contains e.g. `?tags=cs.{example, new}`    |
|cd          |`<@`         |contained in e.g. `?values=cd.{1,2,3}`     |
|not         |`NOT`        |negates another operator                   |
|or          |`OR`         |logical `OR` operator                      |
|and         |`AND`        |logical `AND` operator                     |

## Pagination (offset/limit)

When you query any endpoint in PostgREST, the number of observations returned will be limited to a maximum of 1000 rows (set via `max-rows` config option in the `grest.conf` file. This - however - is a result of a paginated call, wherein the [ up to ] 1000 records you see without any parameters is the first page. If you want to see the next 1000 results, you can always append `offset=1000` to view the next set of results. But what if 1000 is too high for your use-case and you want smaller page? Well, you can specify a smaller limit using parameter `limit`, which will see shortly in an example below. The obvious question at this point that would cross your mind is - how do I know if I need to offset and what range I am querying? This is where headers come in to your aid.  

The default headers returned by PostgREST will include a `Content-Range` field giving a range of observations returned. For large tables, this range could include a wildcard `*` as it is expensive to query exact count of observations from endpoint. But if you would like to get an estimate count without overloading servers, PostgREST can utilise Postgres's own maintenance thread results (which maintain stats for each table) to provide you a count, by specifying a header `"Profile: count=estimated"`.  

Sounds confusing? Let's see this in practice, to hopefully make it easier.
Consider a simple case where I want query `blocks` endpoint for `block_height` column and focus on `content-range` header to monitor the rows we discussed above.<br><br>

``` bash
curl -s "https://api.koios.rest/api/v0/blocks?select=block_height" -I | grep -i content-range

# content-range: 0-999/*

```

As we can see above, the number of observations returned was 1000 (range being 0-999), but the total size was not queried to avoid wait times. Now, let's modify this default behaviour to query rows beyond the first 999, but this time - also add another clause to limit results by 500. We can do this using `offset=1000` and `limit=500` as below:<br><br>

``` bash
curl -s "https://api.koios.rest/api/v0/blocks?select=block_height&offset=1000&limit=500" -I | grep -i content-range

# content-range: 1000-1499/*

```

There is also another method to achieve the above, instead of adding parameters to the URL itself, you can specify a `Range` header as below to achieve something similar:<br><br>

``` bash
curl -s "https://api.koios.rest/api/v0/blocks?select=block_height" -H "Range: 1000-1499" -I | grep -i content-range

# content-range: 1000-1499/*

```

The above methods for pagination are very useful to keep your queries light as well as process the output in smaller pages, making better use of your resources and respecting server timeouts for response times.

## Ordering

You can set a sorting order for returned queries against specific column(s).
Consider example where you want to check `epoch` and `epoch_slot` for the first 5 blocks created by a particular pool, i.e. you can set order to ascending based on block_height column and add horizontal filter for that pool ID as below:<br><br>

``` bash
curl -s "https://api.koios.rest/api/v0/blocks?pool=eq.pool155efqn9xpcf73pphkk88cmlkdwx4ulkg606tne970qswczg3asc&order=block_height.asc&limit=5"

# [{"hash":"610b4c7bbebeeb212bd002885048cc33154ba29f39919d62a3d96de05d315706","epoch":236,"abs_slot":16594295,"epoch_slot":5495,"block_height":5086774,"block_time":1608160586,"tx_count":1,"vrf_key":"vrf_vk18x0e7dx8j37gdxftnn8ru6jcxs7n6acdazc4ykeda2ygjwg9a7ls7ns699","pool":"pool155efqn9xpcf73pphkk88cmlkdwx4ulkg606tne970qswczg3asc","op_cert_counter":1},
# {"hash":"d93d1db5275329ab695d30c06a35124038d8d9af64fc2b0aa082b8aa43da4164","epoch":236,"abs_slot":16597729,"epoch_slot":8929,"block_height":5086944,"block_time":1608164020,"tx_count":7,"vrf_key":"vrf_vk18x0e7dx8j37gdxftnn8ru6jcxs7n6acdazc4ykeda2ygjwg9a7ls7ns699","pool":"pool155efqn9xpcf73pphkk88cmlkdwx4ulkg606tne970qswczg3asc","op_cert_counter":1},
# {"hash":"dc9496eae64294b46f07eb20499ae6dae4d81fdc67c63c354397db91bda1ee55","epoch":236,"abs_slot":16598058,"epoch_slot":9258,"block_height":5086962,"block_time":1608164349,"tx_count":1,"vrf_key":"vrf_vk18x0e7dx8j37gdxftnn8ru6jcxs7n6acdazc4ykeda2ygjwg9a7ls7ns699","pool":"pool155efqn9xpcf73pphkk88cmlkdwx4ulkg606tne970qswczg3asc","op_cert_counter":1},
# {"hash":"6ebc7b734c513bc19290d96ca573a09cac9503c5a349dd9892b9ab43f917f9bd","epoch":236,"abs_slot":16601491,"epoch_slot":12691,"block_height":5087097,"block_time":1608167782,"tx_count":0,"vrf_key":"vrf_vk18x0e7dx8j37gdxftnn8ru6jcxs7n6acdazc4ykeda2ygjwg9a7ls7ns699","pool":"pool155efqn9xpcf73pphkk88cmlkdwx4ulkg606tne970qswczg3asc","op_cert_counter":1},
# {"hash":"2eac97548829fc312858bc56a40f7ce3bf9b0ca27ee8530283ccebb3963de1c0","epoch":236,"abs_slot":16602308,"epoch_slot":13508,"block_height":5087136,"block_time":1608168599,"tx_count":1,"vrf_key":"vrf_vk18x0e7dx8j37gdxftnn8ru6jcxs7n6acdazc4ykeda2ygjwg9a7ls7ns699","pool":"pool155efqn9xpcf73pphkk88cmlkdwx4ulkg606tne970qswczg3asc","op_cert_counter":1}]
```

## Response Formats

You can get the results from the PostgREST endpoints in CSV or JSON formats. The default response format will always be JSON, but if you'd like to switch, you can do so by specifying header `'Accept: text/csv'` or `'Accept: application/json'`.
Below is an example of JSON/CSV output making use of above to print first in JSON (default), and then override response format to CSV.<br><br>

``` bash
curl -s "https://api.koios.rest/api/v0/blocks?select=epoch,epoch_slot,block_time&limit=3"

# [{"epoch":318,"epoch_slot":27867,"block_time":1643606958},
# {"epoch":318,"epoch_slot":27841,"block_time":1643606932},
# {"epoch":318,"epoch_slot":27839,"block_time":1643606930}]

curl -s "https://api.koios.rest/api/v0/blocks?select=epoch,epoch_slot,block_time&limit=3" -H "Accept: text/csv"

# epoch,epoch_slot,block_time
# 318,28491,1643607582
# 318,28479,1643607570
# 318,28406,1643607497

```

## Limits

While use of Koios is completely free and there are no registration requirements to the usage, the monitoring layer will only restrict spam requests that can potentially cause high amount of load to backends. The emphasis is on using list of objects first, and then [bulk where available] query specific objects to drill down where possible - which forms higher performance results to consumer as well as instance provider. Some basic protection against patterns that could cause unexpected resource spikes are protected as per below:

  - Burst Limit: A single IP can query an endpoint up to 100 times within 10 seconds (that's about 8.64 million requests within a day). The sleep time if a limit is crossed is minimal (60 seconds) for that IP - during which, the monitoring layer will return HTTP Status `429 - Too many requests`.  
  - Pagination/Limits: Any query results fetched will be paginated by 1000 records (you can reduce limit and or control pagination offsets on URL itself, see API > Pagination section for more details).
  - Query timeout: If a query from server takes more than 30 seconds, it will return a HTTP Status of `504 - Gateway timeout`. This is because we would want to ensure you're using the queries optimally, and more often than not - it would indicate that particular endpoint is not optimised (or the network connectivity is not optimal between servers).

Yet, there may be cases where the above restrictions may need exceptions (for example, an explorer or a wallet might need more connections than above - going beyond the Burst Limit). For such cases, it is best to approach the team and we can work towards a solution.


# Community projects

A big thank you to the following projects who are already starting to use Koios from early days. A list of tools, libraries and projects utilising Koios (atleast those who'd like to be named) can be found [here](https://www.koios.rest/api-calls-tools-and-libraries)

# FAQ

### Is there a price attached to using services?
For most of the queries, there are no charges. But there are DDoS protection and strict timeout rules (see API Usage) that may prevent heavy consumers from using this *remotely* (for which, there should be an interaction to ensure the usage is proportional to sizing and traffic expected).

### Who are the folks behind Koios?
It will be increasing list of community builders. But for initial think-tank and efforts, the work done is primarily by [guild-operators](https://cardano-community.github.io/guild-operators)
who are a well-recognised team of members behind Cardano tools like CNTools, gLiveView, topologyUpdater, etc. We also run a parallel a short (60-min) epoch blockchain, viz, guild used by many
for experiments.

### I am only interested in collaborating on queries, where can I find the code and how to collaborate?
All the Postgres codebase against db-sync instance is available on guild-operator's github repo [here](https://github.com/cardano-community/guild-operators/tree/alpha/files/grest/rpc). Feel free to raise an issue/PR to discuss anything related to those queries.

### I am not sure how to set up an instance. Is there an easy start guide?
Yes, there is a setup script (expect you to read carefully the help section) and instructions [here](https://cardano-community.github.io/guild-operators/Build/grest/). Should you need any assistance, feel free to hop in to the [discussion group](https://t.me/joinchat/+zE4Lce_QUepiY2U1).

### Too much reading, I want to discuss in person
There are bi-weekly calls held that anyone is free to join - or you can drop in to the [telegram group](https://t.me/+zE4Lce_QUepiY2U1) and start a discussion from there.

 * OpenAPI spec version: 1.0.10
 */
import type {
  Tip,
  Genesis,
  Totals,
  GetTotalsParams,
  ParamUpdates,
  EpochInfo,
  GetEpochInfoParams,
  EpochParams,
  GetEpochParamsParams,
  EpochBlockProtocols,
  GetEpochBlockProtocolsParams,
  Blocks,
  BlockInfo,
  BlockHashesBody,
  BlockTxs,
  TxInfo,
  TxIdsBody,
  TxUtxos,
  TxMetadata,
  TxMetalabels,
  TxbinBody,
  TxStatus,
  AddressInfo,
  PaymentAddressesBody,
  AddressTxs,
  AddressTxsBody,
  CredentialUtxos,
  CredentialUtxosBody,
  AddressAssets,
  CredentialTxs,
  CredentialTxsBody,
  AccountList,
  AccountInfo,
  StakeAddressesBody,
  AccountUtxos,
  GetAccountUtxosParams,
  AccountRewards,
  StakeAddressesWithEpochNoBody,
  AccountUpdates,
  AccountAddresses,
  StakeAddressesWithFirstOnlyAndEmptyBody,
  AccountAssets,
  AccountHistory,
  AssetList,
  AssetTokenRegistry,
  AssetAddresses,
  GetAssetAddressesParams,
  GetAssetAddressListParams,
  AssetNftAddress,
  GetAssetNftAddressParams,
  AssetInfo,
  GetAssetInfoParams,
  AssetListBody,
  AssetHistory,
  GetAssetHistoryParams,
  PolicyAssetAddresses,
  GetPolicyAssetAddressesParams,
  PolicyAssetInfo,
  GetPolicyAssetInfoParams,
  GetAssetPolicyInfoParams,
  PolicyAssetList,
  GetPolicyAssetListParams,
  AssetSummary,
  GetAssetSummaryParams,
  AssetTxs,
  GetAssetTxsParams,
  PoolList,
  PoolInfo,
  PoolIdsBody,
  PoolSnapshot,
  GetPoolStakeSnapshotParams,
  PoolDelegators,
  GetPoolDelegatorsParams,
  PoolDelegatorsHistory,
  GetPoolDelegatorsHistoryParams,
  PoolBlocks,
  GetPoolBlocksParams,
  PoolHistoryInfo,
  GetPoolHistoryParams,
  PoolUpdates,
  GetPoolUpdatesParams,
  PoolRelays,
  PoolMetadata,
  PoolIdsOptionalBody,
  NativeScriptList,
  PlutusScriptList,
  ScriptRedeemers,
  GetScriptRedeemersParams,
  DatumInfo,
  DatumHashesBody,
} from '../types';

import {
  bigIntsTip,
  bigIntsGenesis,
  bigIntsTotals,
  bigIntsParamUpdates,
  bigIntsEpochInfo,
  bigIntsEpochParams,
  bigIntsEpochBlockProtocols,
  bigIntsBlocks,
  bigIntsBlockInfo,
  bigIntsBlockTxs,
  bigIntsTxInfo,
  bigIntsTxUtxos,
  bigIntsTxMetadata,
  bigIntsTxMetalabels,
  bigIntsTxStatus,
  bigIntsAddressInfo,
  bigIntsAddressTxs,
  bigIntsCredentialUtxos,
  bigIntsAddressAssets,
  bigIntsCredentialTxs,
  bigIntsAccountList,
  bigIntsAccountInfo,
  bigIntsAccountUtxos,
  bigIntsAccountRewards,
  bigIntsAccountUpdates,
  bigIntsAccountAddresses,
  bigIntsAccountAssets,
  bigIntsAccountHistory,
  bigIntsAssetList,
  bigIntsAssetTokenRegistry,
  bigIntsAssetAddresses,
  bigIntsAssetNftAddress,
  bigIntsAssetInfo,
  bigIntsAssetHistory,
  bigIntsPolicyAssetAddresses,
  bigIntsPolicyAssetInfo,
  bigIntsPolicyAssetList,
  bigIntsAssetSummary,
  bigIntsAssetTxs,
  bigIntsPoolList,
  bigIntsPoolInfo,
  bigIntsPoolSnapshot,
  bigIntsPoolDelegators,
  bigIntsPoolDelegatorsHistory,
  bigIntsPoolBlocks,
  bigIntsPoolHistoryInfo,
  bigIntsPoolUpdates,
  bigIntsPoolRelays,
  bigIntsPoolMetadata,
  bigIntsNativeScriptList,
  bigIntsPlutusScriptList,
  bigIntsScriptRedeemers,
  bigIntsDatumInfo,
} from '../types';

import { createAxiosInstance, JsonFieldBigintFactory } from '../axios';

export const getKoiosAPI = (url: string, authToken?: string) => {
  const instance = createAxiosInstance(url, authToken);
  /**
   * Get the tip info about the latest block seen by chain
   * @summary Query Chain Tip
   */
  const getTip = () => {
    return instance<Tip>({
      url: `/tip`,
      method: 'get',
      transformResponse: JsonFieldBigintFactory(bigIntsTip),
    });
  };

  /**
   * Get the Genesis parameters used to start specific era on chain
   * @summary Get Genesis info
   */
  const getGenesis = () => {
    return instance<Genesis>({
      url: `/genesis`,
      method: 'get',
      transformResponse: JsonFieldBigintFactory(bigIntsGenesis),
    });
  };

  /**
   * Get the circulating utxo, treasury, rewards, supply and reserves in lovelace for specified epoch, all epochs if empty
   * @summary Get historical tokenomic stats
   */
  const getTotals = (params?: GetTotalsParams) => {
    return instance<Totals>({
      url: `/totals`,
      method: 'get',
      params,
      transformResponse: JsonFieldBigintFactory(bigIntsTotals),
    });
  };

  /**
   * Get all parameter update proposals submitted to the chain starting Shelley era
   * @summary Param Update Proposals
   */
  const getParamUpdates = () => {
    return instance<ParamUpdates>({
      url: `/param_updates`,
      method: 'get',
      transformResponse: JsonFieldBigintFactory(bigIntsParamUpdates),
    });
  };

  /**
   * Get the epoch information, all epochs if no epoch specified
   * @summary Epoch Information
   */
  const getEpochInfo = (params?: GetEpochInfoParams) => {
    return instance<EpochInfo>({
      url: `/epoch_info`,
      method: 'get',
      params,
      transformResponse: JsonFieldBigintFactory(bigIntsEpochInfo),
    });
  };

  /**
   * Get the protocol parameters for specific epoch, returns information about all epochs if no epoch specified
   * @summary Epoch's Protocol Parameters
   */
  const getEpochParams = (params?: GetEpochParamsParams) => {
    return instance<EpochParams>({
      url: `/epoch_params`,
      method: 'get',
      params,
      transformResponse: JsonFieldBigintFactory(bigIntsEpochParams),
    });
  };

  /**
   * Get the information about block protocol distribution in epoch
   * @summary Epoch's Block Protocols
   */
  const getEpochBlockProtocols = (params?: GetEpochBlockProtocolsParams) => {
    return instance<EpochBlockProtocols>({
      url: `/epoch_block_protocols`,
      method: 'get',
      params,
      transformResponse: JsonFieldBigintFactory(bigIntsEpochBlockProtocols),
    });
  };

  /**
   * Get summarised details about all blocks (paginated - latest first)
   * @summary Block List
   */
  const getBlocks = () => {
    return instance<Blocks>({
      url: `/blocks`,
      method: 'get',
      transformResponse: JsonFieldBigintFactory(bigIntsBlocks),
    });
  };

  /**
   * Get detailed information about a specific block
   * @summary Block Information
   */
  const postBlockInfo = (blockHashesBody: BlockHashesBody) => {
    return instance<BlockInfo>({
      url: `/block_info`,
      method: 'post',
      headers: { 'Content-Type': 'application/json' },
      data: blockHashesBody,
      transformResponse: JsonFieldBigintFactory(bigIntsBlockInfo),
    });
  };

  /**
   * Get a list of all transactions included in provided blocks
   * @summary Block Transactions
   */
  const postBlockTxs = (blockHashesBody: BlockHashesBody) => {
    return instance<BlockTxs>({
      url: `/block_txs`,
      method: 'post',
      headers: { 'Content-Type': 'application/json' },
      data: blockHashesBody,
      transformResponse: JsonFieldBigintFactory(bigIntsBlockTxs),
    });
  };

  /**
   * Get detailed information about transaction(s)
   * @summary Transaction Information
   */
  const postTxInfo = (txIdsBody: TxIdsBody) => {
    return instance<TxInfo>({
      url: `/tx_info`,
      method: 'post',
      headers: { 'Content-Type': 'application/json' },
      data: txIdsBody,
      transformResponse: JsonFieldBigintFactory(bigIntsTxInfo),
    });
  };

  /**
   * Get UTxO set (inputs/outputs) of transactions.
   * @summary Transaction UTxOs
   */
  const postTxUtxos = (txIdsBody: TxIdsBody) => {
    return instance<TxUtxos>({
      url: `/tx_utxos`,
      method: 'post',
      headers: { 'Content-Type': 'application/json' },
      data: txIdsBody,
      transformResponse: JsonFieldBigintFactory(bigIntsTxUtxos),
    });
  };

  /**
   * Get metadata information (if any) for given transaction(s)
   * @summary Transaction Metadata
   */
  const postTxMetadata = (txIdsBody: TxIdsBody) => {
    return instance<TxMetadata>({
      url: `/tx_metadata`,
      method: 'post',
      headers: { 'Content-Type': 'application/json' },
      data: txIdsBody,
      transformResponse: JsonFieldBigintFactory(bigIntsTxMetadata),
    });
  };

  /**
   * Get a list of all transaction metalabels
   * @summary Transaction Metadata Labels
   */
  const getTxMetalabels = () => {
    return instance<TxMetalabels>({
      url: `/tx_metalabels`,
      method: 'get',
      transformResponse: JsonFieldBigintFactory(bigIntsTxMetalabels),
    });
  };

  /**
   * Submit an already serialized transaction to the network.
   * @summary Submit Transaction
   */
  const postSubmittx = (txbinBody: TxbinBody) => {
    return instance<string>({
      url: `/submittx`,
      method: 'post',
      headers: { 'Content-Type': 'application/cbor' },
      data: txbinBody,
    });
  };

  /**
   * Get the number of block confirmations for a given transaction hash list
   * @summary Transaction Status (Block Confirmations)
   */
  const postTxStatus = (txIdsBody: TxIdsBody) => {
    return instance<TxStatus>({
      url: `/tx_status`,
      method: 'post',
      headers: { 'Content-Type': 'application/json' },
      data: txIdsBody,
      transformResponse: JsonFieldBigintFactory(bigIntsTxStatus),
    });
  };

  /**
   * Get address info - balance, associated stake address (if any) and UTxO set for given addresses
   * @summary Address Information
   */
  const postAddressInfo = (paymentAddressesBody: PaymentAddressesBody) => {
    return instance<AddressInfo>({
      url: `/address_info`,
      method: 'post',
      headers: { 'Content-Type': 'application/json' },
      data: paymentAddressesBody,
      transformResponse: JsonFieldBigintFactory(bigIntsAddressInfo),
    });
  };

  /**
   * Get the transaction hash list of input address array, optionally filtering after specified block height (inclusive)
   * @summary Address Transactions
   */
  const postAddressTxs = (addressTxsBody: AddressTxsBody) => {
    return instance<AddressTxs>({
      url: `/address_txs`,
      method: 'post',
      headers: { 'Content-Type': 'application/json' },
      data: addressTxsBody,
      transformResponse: JsonFieldBigintFactory(bigIntsAddressTxs),
    });
  };

  /**
   * Get a list of UTxO against input payment credential array including their balances
   * @summary UTxOs from payment credentials
   */
  const postCredentialUtxos = (credentialUtxosBody: CredentialUtxosBody) => {
    return instance<CredentialUtxos>({
      url: `/credential_utxos`,
      method: 'post',
      headers: { 'Content-Type': 'application/json' },
      data: credentialUtxosBody,
      transformResponse: JsonFieldBigintFactory(bigIntsCredentialUtxos),
    });
  };

  /**
   * Get the list of all the assets (policy, name and quantity) for given addresses
   * @summary Address Assets
   */
  const postAddressAssets = (paymentAddressesBody: PaymentAddressesBody) => {
    return instance<AddressAssets>({
      url: `/address_assets`,
      method: 'post',
      headers: { 'Content-Type': 'application/json' },
      data: paymentAddressesBody,
      transformResponse: JsonFieldBigintFactory(bigIntsAddressAssets),
    });
  };

  /**
   * Get the transaction hash list of input payment credential array, optionally filtering after specified block height (inclusive)
   * @summary Transactions from payment credentials
   */
  const postCredentialTxs = (credentialTxsBody: CredentialTxsBody) => {
    return instance<CredentialTxs>({
      url: `/credential_txs`,
      method: 'post',
      headers: { 'Content-Type': 'application/json' },
      data: credentialTxsBody,
      transformResponse: JsonFieldBigintFactory(bigIntsCredentialTxs),
    });
  };

  /**
   * Get a list of all stake addresses that have atleast 1 transaction
   * @summary Account List
   */
  const getAccountList = () => {
    return instance<AccountList>({
      url: `/account_list`,
      method: 'get',
      transformResponse: JsonFieldBigintFactory(bigIntsAccountList),
    });
  };

  /**
   * Get the account information for given stake addresses
   * @summary Account Information
   */
  const postAccountInfo = (stakeAddressesBody: StakeAddressesBody) => {
    return instance<AccountInfo>({
      url: `/account_info`,
      method: 'post',
      headers: { 'Content-Type': 'application/json' },
      data: stakeAddressesBody,
      transformResponse: JsonFieldBigintFactory(bigIntsAccountInfo),
    });
  };

  /**
   * Get a list of all UTxOs for a given stake address (account)
   * @summary Account UTxOs
   */
  const getAccountUtxos = (params: GetAccountUtxosParams) => {
    return instance<AccountUtxos>({
      url: `/account_utxos`,
      method: 'get',
      params,
      transformResponse: JsonFieldBigintFactory(bigIntsAccountUtxos),
    });
  };

  /**
   * Get the cached account information for given stake addresses, effective for registered accounts
   * @summary Account Information (Cached)
   */
  const postAccountInfoCached = (stakeAddressesBody: StakeAddressesBody) => {
    return instance<AccountInfo>({
      url: `/account_info_cached`,
      method: 'post',
      headers: { 'Content-Type': 'application/json' },
      data: stakeAddressesBody,
      transformResponse: JsonFieldBigintFactory(bigIntsAccountInfo),
    });
  };

  /**
   * Get the full rewards history (including MIR) for given stake addresses
   * @summary Account Rewards
   */
  const postAccountRewards = (
    stakeAddressesWithEpochNoBody: StakeAddressesWithEpochNoBody
  ) => {
    return instance<AccountRewards>({
      url: `/account_rewards`,
      method: 'post',
      headers: { 'Content-Type': 'application/json' },
      data: stakeAddressesWithEpochNoBody,
      transformResponse: JsonFieldBigintFactory(bigIntsAccountRewards),
    });
  };

  /**
   * Get the account updates (registration, deregistration, delegation and withdrawals) for given stake addresses
   * @summary Account Updates
   */
  const postAccountUpdates = (stakeAddressesBody: StakeAddressesBody) => {
    return instance<AccountUpdates>({
      url: `/account_updates`,
      method: 'post',
      headers: { 'Content-Type': 'application/json' },
      data: stakeAddressesBody,
      transformResponse: JsonFieldBigintFactory(bigIntsAccountUpdates),
    });
  };

  /**
   * Get all addresses associated with given staking accounts
   * @summary Account Addresses
   */
  const postAccountAddresses = (
    stakeAddressesWithFirstOnlyAndEmptyBody: StakeAddressesWithFirstOnlyAndEmptyBody
  ) => {
    return instance<AccountAddresses>({
      url: `/account_addresses`,
      method: 'post',
      headers: { 'Content-Type': 'application/json' },
      data: stakeAddressesWithFirstOnlyAndEmptyBody,
      transformResponse: JsonFieldBigintFactory(bigIntsAccountAddresses),
    });
  };

  /**
   * Get the native asset balance for a given stake address
   * @summary Account Assets
   */
  const postAccountAssets = (stakeAddressesBody: StakeAddressesBody) => {
    return instance<AccountAssets>({
      url: `/account_assets`,
      method: 'post',
      headers: { 'Content-Type': 'application/json' },
      data: stakeAddressesBody,
      transformResponse: JsonFieldBigintFactory(bigIntsAccountAssets),
    });
  };

  /**
   * Get the staking history of given stake addresses (accounts)
   * @summary Account History
   */
  const postAccountHistory = (
    stakeAddressesWithEpochNoBody: StakeAddressesWithEpochNoBody
  ) => {
    return instance<AccountHistory>({
      url: `/account_history`,
      method: 'post',
      headers: { 'Content-Type': 'application/json' },
      data: stakeAddressesWithEpochNoBody,
      transformResponse: JsonFieldBigintFactory(bigIntsAccountHistory),
    });
  };

  /**
   * Get the list of all native assets (paginated)
   * @summary Asset List
   */
  const getAssetList = () => {
    return instance<AssetList>({
      url: `/asset_list`,
      method: 'get',
      transformResponse: JsonFieldBigintFactory(bigIntsAssetList),
    });
  };

  /**
   * Get a list of assets registered via token registry on github
   * @summary Asset Token Registry
   */
  const getAssetTokenRegistry = () => {
    return instance<AssetTokenRegistry>({
      url: `/asset_token_registry`,
      method: 'get',
      transformResponse: JsonFieldBigintFactory(bigIntsAssetTokenRegistry),
    });
  };

  /**
   * Get the list of all addresses holding a given asset <br><br> `Note - Due to cardano's UTxO design and usage from projects, asset to addresses map can be infinite. Thus, for a small subset of active projects with millions of transactions, these might end up with timeouts (HTTP code 504) on free layer. Such large-scale projects are free to subscribe to query layers to have a dedicated cache table for themselves served via Koios.`
   * @summary Asset Addresses
   */
  const getAssetAddresses = (params: GetAssetAddressesParams) => {
    return instance<AssetAddresses>({
      url: `/asset_addresses`,
      method: 'get',
      params,
      transformResponse: JsonFieldBigintFactory(bigIntsAssetAddresses),
    });
  };

  /**
   * Get the list of all addresses holding a given asset (replaced by asset_addresses)
   * @summary Asset Address List [DEPRECATED]
   */
  const getAssetAddressList = (params: GetAssetAddressListParams) => {
    return instance<AssetAddresses>({
      url: `/asset_address_list`,
      method: 'get',
      params,
      transformResponse: JsonFieldBigintFactory(bigIntsAssetAddresses),
    });
  };

  /**
   * Get the address where specified NFT currently reside on.
   * @summary NFT Address
   */
  const getAssetNftAddress = (params: GetAssetNftAddressParams) => {
    return instance<AssetNftAddress>({
      url: `/asset_nft_address`,
      method: 'get',
      params,
      transformResponse: JsonFieldBigintFactory(bigIntsAssetNftAddress),
    });
  };

  /**
   * Get the information of an asset including first minting & token registry metadata
   * @summary Asset Information
   */
  const getAssetInfo = (params: GetAssetInfoParams) => {
    return instance<AssetInfo>({
      url: `/asset_info`,
      method: 'get',
      params,
      transformResponse: JsonFieldBigintFactory(bigIntsAssetInfo),
    });
  };

  /**
   * Get the information of a list of assets including first minting & token registry metadata
   * @summary Asset Information (Bulk)
   */
  const postAssetInfo = (assetListBody: AssetListBody) => {
    return instance<AssetInfo>({
      url: `/asset_info`,
      method: 'post',
      headers: { 'Content-Type': 'application/json' },
      data: assetListBody,
      transformResponse: JsonFieldBigintFactory(bigIntsAssetInfo),
    });
  };

  /**
   * Get the mint/burn history of an asset
   * @summary Asset History
   */
  const getAssetHistory = (params: GetAssetHistoryParams) => {
    return instance<AssetHistory>({
      url: `/asset_history`,
      method: 'get',
      params,
      transformResponse: JsonFieldBigintFactory(bigIntsAssetHistory),
    });
  };

  /**
   * Get the list of addresses with quantity for each asset on the given policy <br><br> `Note - Due to cardano's UTxO design and usage from projects, asset to addresses map can be infinite. Thus, for a small subset of active projects with millions of transactions, these might end up with timeouts (HTTP code 504) on free layer. Such large-scale projects are free to subscribe to query layers to have a dedicated cache table for themselves served via Koios.`
   * @summary Policy Asset Address List
   */
  const getPolicyAssetAddresses = (params: GetPolicyAssetAddressesParams) => {
    return instance<PolicyAssetAddresses>({
      url: `/policy_asset_addresses`,
      method: 'get',
      params,
      transformResponse: JsonFieldBigintFactory(bigIntsPolicyAssetAddresses),
    });
  };

  /**
   * Get the information for all assets under the same policy
   * @summary Policy Asset Information
   */
  const getPolicyAssetInfo = (params: GetPolicyAssetInfoParams) => {
    return instance<PolicyAssetInfo>({
      url: `/policy_asset_info`,
      method: 'get',
      params,
      transformResponse: JsonFieldBigintFactory(bigIntsPolicyAssetInfo),
    });
  };

  /**
   * Get the information for all assets under the same policy (replaced by asset_addresses)
   * @summary Asset Policy Information [DEPRECATED]
   */
  const getAssetPolicyInfo = (params: GetAssetPolicyInfoParams) => {
    return instance<PolicyAssetInfo>({
      url: `/asset_policy_info`,
      method: 'get',
      params,
      transformResponse: JsonFieldBigintFactory(bigIntsPolicyAssetInfo),
    });
  };

  /**
   * Get the list of asset under the given policy (including balances)
   * @summary Policy Asset List
   */
  const getPolicyAssetList = (params: GetPolicyAssetListParams) => {
    return instance<PolicyAssetList>({
      url: `/policy_asset_list`,
      method: 'get',
      params,
      transformResponse: JsonFieldBigintFactory(bigIntsPolicyAssetList),
    });
  };

  /**
   * Get the summary of an asset (total transactions exclude minting/total wallets include only wallets with asset balance)
   * @summary Asset Summary
   */
  const getAssetSummary = (params: GetAssetSummaryParams) => {
    return instance<AssetSummary>({
      url: `/asset_summary`,
      method: 'get',
      params,
      transformResponse: JsonFieldBigintFactory(bigIntsAssetSummary),
    });
  };

  /**
   * Get the list of current or all asset transaction hashes (newest first)
   * @summary Asset Transactions
   */
  const getAssetTxs = (params: GetAssetTxsParams) => {
    return instance<AssetTxs>({
      url: `/asset_txs`,
      method: 'get',
      params,
      transformResponse: JsonFieldBigintFactory(bigIntsAssetTxs),
    });
  };

  /**
   * A list of all currently registered/retiring (not retired) pools
   * @summary Pool List
   */
  const getPoolList = () => {
    return instance<PoolList>({
      url: `/pool_list`,
      method: 'get',
      transformResponse: JsonFieldBigintFactory(bigIntsPoolList),
    });
  };

  /**
   * Current pool statuses and details for a specified list of pool ids
   * @summary Pool Information
   */
  const postPoolInfo = (poolIdsBody: PoolIdsBody) => {
    return instance<PoolInfo>({
      url: `/pool_info`,
      method: 'post',
      headers: { 'Content-Type': 'application/json' },
      data: poolIdsBody,
      transformResponse: JsonFieldBigintFactory(bigIntsPoolInfo),
    });
  };

  /**
   * Returns Mark, Set and Go stake snapshots for the selected pool, useful for leaderlog calculation
   * @summary Pool Stake Snapshot
   */
  const getPoolStakeSnapshot = (params: GetPoolStakeSnapshotParams) => {
    return instance<PoolSnapshot>({
      url: `/pool_stake_snapshot`,
      method: 'get',
      params,
      transformResponse: JsonFieldBigintFactory(bigIntsPoolSnapshot),
    });
  };

  /**
   * Return information about live delegators for a given pool.
   * @summary Pool Delegators List
   */
  const getPoolDelegators = (params: GetPoolDelegatorsParams) => {
    return instance<PoolDelegators>({
      url: `/pool_delegators`,
      method: 'get',
      params,
      transformResponse: JsonFieldBigintFactory(bigIntsPoolDelegators),
    });
  };

  /**
   * Return information about active delegators (incl. history) for a given pool and epoch number (all epochs if not specified).
   * @summary Pool Delegators History
   */
  const getPoolDelegatorsHistory = (params: GetPoolDelegatorsHistoryParams) => {
    return instance<PoolDelegatorsHistory>({
      url: `/pool_delegators_history`,
      method: 'get',
      params,
      transformResponse: JsonFieldBigintFactory(bigIntsPoolDelegatorsHistory),
    });
  };

  /**
   * Return information about blocks minted by a given pool for all epochs (or _epoch_no if provided)
   * @summary Pool Blocks
   */
  const getPoolBlocks = (params: GetPoolBlocksParams) => {
    return instance<PoolBlocks>({
      url: `/pool_blocks`,
      method: 'get',
      params,
      transformResponse: JsonFieldBigintFactory(bigIntsPoolBlocks),
    });
  };

  /**
   * Return information about pool stake, block and reward history in a given epoch _epoch_no (or all epochs that pool existed for, in descending order if no _epoch_no was provided)
   * @summary Pool Stake, Block and Reward History
   */
  const getPoolHistory = (params: GetPoolHistoryParams) => {
    return instance<PoolHistoryInfo>({
      url: `/pool_history`,
      method: 'get',
      params,
      transformResponse: JsonFieldBigintFactory(bigIntsPoolHistoryInfo),
    });
  };

  /**
   * Return all pool updates for all pools or only updates for specific pool if specified
   * @summary Pool Updates (History)
   */
  const getPoolUpdates = (params?: GetPoolUpdatesParams) => {
    return instance<PoolUpdates>({
      url: `/pool_updates`,
      method: 'get',
      params,
      transformResponse: JsonFieldBigintFactory(bigIntsPoolUpdates),
    });
  };

  /**
   * A list of registered relays for all currently registered/retiring (not retired) pools
   * @summary Pool Relays
   */
  const getPoolRelays = () => {
    return instance<PoolRelays>({
      url: `/pool_relays`,
      method: 'get',
      transformResponse: JsonFieldBigintFactory(bigIntsPoolRelays),
    });
  };

  /**
   * Metadata (on & off-chain) for all currently registered/retiring (not retired) pools
   * @summary Pool Metadata
   */
  const postPoolMetadata = (poolIdsOptionalBody: PoolIdsOptionalBody) => {
    return instance<PoolMetadata>({
      url: `/pool_metadata`,
      method: 'post',
      headers: { 'Content-Type': 'application/json' },
      data: poolIdsOptionalBody,
      transformResponse: JsonFieldBigintFactory(bigIntsPoolMetadata),
    });
  };

  /**
   * List of all existing native script hashes along with their creation transaction hashes
   * @summary Native Script List
   */
  const getNativeScriptList = () => {
    return instance<NativeScriptList>({
      url: `/native_script_list`,
      method: 'get',
      transformResponse: JsonFieldBigintFactory(bigIntsNativeScriptList),
    });
  };

  /**
   * List of all existing Plutus script hashes along with their creation transaction hashes
   * @summary Plutus Script List
   */
  const getPlutusScriptList = () => {
    return instance<PlutusScriptList>({
      url: `/plutus_script_list`,
      method: 'get',
      transformResponse: JsonFieldBigintFactory(bigIntsPlutusScriptList),
    });
  };

  /**
   * List of all redeemers for a given script hash
   * @summary Script Redeemers
   */
  const getScriptRedeemers = (params: GetScriptRedeemersParams) => {
    return instance<ScriptRedeemers>({
      url: `/script_redeemers`,
      method: 'get',
      params,
      transformResponse: JsonFieldBigintFactory(bigIntsScriptRedeemers),
    });
  };

  /**
   * List of datum information for given datum hashes
   * @summary Datum Information
   */
  const postDatumInfo = (datumHashesBody: DatumHashesBody) => {
    return instance<DatumInfo>({
      url: `/datum_info`,
      method: 'post',
      headers: { 'Content-Type': 'application/json' },
      data: datumHashesBody,
      transformResponse: JsonFieldBigintFactory(bigIntsDatumInfo),
    });
  };

  return {
    getTip,
    getGenesis,
    getTotals,
    getParamUpdates,
    getEpochInfo,
    getEpochParams,
    getEpochBlockProtocols,
    getBlocks,
    postBlockInfo,
    postBlockTxs,
    postTxInfo,
    postTxUtxos,
    postTxMetadata,
    getTxMetalabels,
    postSubmittx,
    postTxStatus,
    postAddressInfo,
    postAddressTxs,
    postCredentialUtxos,
    postAddressAssets,
    postCredentialTxs,
    getAccountList,
    postAccountInfo,
    getAccountUtxos,
    postAccountInfoCached,
    postAccountRewards,
    postAccountUpdates,
    postAccountAddresses,
    postAccountAssets,
    postAccountHistory,
    getAssetList,
    getAssetTokenRegistry,
    getAssetAddresses,
    getAssetAddressList,
    getAssetNftAddress,
    getAssetInfo,
    postAssetInfo,
    getAssetHistory,
    getPolicyAssetAddresses,
    getPolicyAssetInfo,
    getAssetPolicyInfo,
    getPolicyAssetList,
    getAssetSummary,
    getAssetTxs,
    getPoolList,
    postPoolInfo,
    getPoolStakeSnapshot,
    getPoolDelegators,
    getPoolDelegatorsHistory,
    getPoolBlocks,
    getPoolHistory,
    getPoolUpdates,
    getPoolRelays,
    postPoolMetadata,
    getNativeScriptList,
    getPlutusScriptList,
    getScriptRedeemers,
    postDatumInfo,
  };
};

type AwaitedInput<T> = PromiseLike<T> | T;

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;

export type GetTipResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['getTip']>>
>;
export type GetGenesisResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['getGenesis']>>
>;
export type GetTotalsResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['getTotals']>>
>;
export type GetParamUpdatesResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['getParamUpdates']>>
>;
export type GetEpochInfoResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['getEpochInfo']>>
>;
export type GetEpochParamsResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['getEpochParams']>>
>;
export type GetEpochBlockProtocolsResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['getEpochBlockProtocols']>>
>;
export type GetBlocksResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['getBlocks']>>
>;
export type PostBlockInfoResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['postBlockInfo']>>
>;
export type PostBlockTxsResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['postBlockTxs']>>
>;
export type PostTxInfoResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['postTxInfo']>>
>;
export type PostTxUtxosResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['postTxUtxos']>>
>;
export type PostTxMetadataResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['postTxMetadata']>>
>;
export type GetTxMetalabelsResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['getTxMetalabels']>>
>;
export type PostSubmittxResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['postSubmittx']>>
>;
export type PostTxStatusResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['postTxStatus']>>
>;
export type PostAddressInfoResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['postAddressInfo']>>
>;
export type PostAddressTxsResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['postAddressTxs']>>
>;
export type PostCredentialUtxosResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['postCredentialUtxos']>>
>;
export type PostAddressAssetsResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['postAddressAssets']>>
>;
export type PostCredentialTxsResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['postCredentialTxs']>>
>;
export type GetAccountListResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['getAccountList']>>
>;
export type PostAccountInfoResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['postAccountInfo']>>
>;
export type GetAccountUtxosResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['getAccountUtxos']>>
>;
export type PostAccountInfoCachedResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['postAccountInfoCached']>>
>;
export type PostAccountRewardsResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['postAccountRewards']>>
>;
export type PostAccountUpdatesResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['postAccountUpdates']>>
>;
export type PostAccountAddressesResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['postAccountAddresses']>>
>;
export type PostAccountAssetsResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['postAccountAssets']>>
>;
export type PostAccountHistoryResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['postAccountHistory']>>
>;
export type GetAssetListResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['getAssetList']>>
>;
export type GetAssetTokenRegistryResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['getAssetTokenRegistry']>>
>;
export type GetAssetAddressesResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['getAssetAddresses']>>
>;
export type GetAssetAddressListResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['getAssetAddressList']>>
>;
export type GetAssetNftAddressResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['getAssetNftAddress']>>
>;
export type GetAssetInfoResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['getAssetInfo']>>
>;
export type PostAssetInfoResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['postAssetInfo']>>
>;
export type GetAssetHistoryResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['getAssetHistory']>>
>;
export type GetPolicyAssetAddressesResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['getPolicyAssetAddresses']>>
>;
export type GetPolicyAssetInfoResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['getPolicyAssetInfo']>>
>;
export type GetAssetPolicyInfoResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['getAssetPolicyInfo']>>
>;
export type GetPolicyAssetListResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['getPolicyAssetList']>>
>;
export type GetAssetSummaryResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['getAssetSummary']>>
>;
export type GetAssetTxsResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['getAssetTxs']>>
>;
export type GetPoolListResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['getPoolList']>>
>;
export type PostPoolInfoResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['postPoolInfo']>>
>;
export type GetPoolStakeSnapshotResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['getPoolStakeSnapshot']>>
>;
export type GetPoolDelegatorsResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['getPoolDelegators']>>
>;
export type GetPoolDelegatorsHistoryResult = NonNullable<
  Awaited<
    ReturnType<ReturnType<typeof getKoiosAPI>['getPoolDelegatorsHistory']>
  >
>;
export type GetPoolBlocksResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['getPoolBlocks']>>
>;
export type GetPoolHistoryResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['getPoolHistory']>>
>;
export type GetPoolUpdatesResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['getPoolUpdates']>>
>;
export type GetPoolRelaysResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['getPoolRelays']>>
>;
export type PostPoolMetadataResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['postPoolMetadata']>>
>;
export type GetNativeScriptListResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['getNativeScriptList']>>
>;
export type GetPlutusScriptListResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['getPlutusScriptList']>>
>;
export type GetScriptRedeemersResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['getScriptRedeemers']>>
>;
export type PostDatumInfoResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof getKoiosAPI>['postDatumInfo']>>
>;
